# Практическое задание по теме «Troobleshooting»

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

### Решение

Изучим [документацию MongoDB](https://www.mongodb.com/docs/manual/administration/).

1. Команда для остановки запроса `db.killOp()`. Для её использования необходимо выяснить `id` запроса. Например, найдём все активные запросы, которые выполняются более 60 секунд:

```shell
db.currentOp(
   {
     "active" : true,
     "secs_running" : { "$gt" : 60 },
     "ns" : /^db1\./
   }
)
```

И передадим их в `db.killOp()`:  

```  
db.killOp(<opid_1>)
db.killOp(<opid_2>)
...
```

2. Решение проблем с долгими или зависающими запросами:

* использование инструмента Free Monitoring;
* использование метода `cursor.explain()` для изучения плана запроса и исследования возможностей оптимизации;
* использование метода `cursor.maxTimeMS(<time limit>)` для ограничения времени выполнения запроса.

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?
 
### Решение

Изучим [документацию Redis Diagnosing latency issues](https://redis.io/docs/reference/optimization/latency/).

Для исследования проблемы необходимо:

* проверить Redis на наличие блокирующих slow-команд: `redis-cli SLOWLOG GET N`; 
* проверить latency: `redis-cli --latency -h 'host' -p 'port'`. При наличии проблем, необходимо произвести контроль настроек окружения;
* изучить количество операции на запись. Так как Redis однопоточный, он может не справляться с нагрузкой. 

## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

### Решение

Для того чтобы локализовать проблему необходимо проанализировать логи и выяснить какие именно запросы приводят к 2013 ошибке. 

С ростом количества записей в БД увеличивается время ответа. Это связано с тем, что необходимо больше времени и ресурсов для возврата результата. Одним из вариантов решения проблемы является простое увеличение времени продолжительности паузы между запросом и ответом, а именно параметров: `connect_timeout`, `interactive_timeout` и `wait_timeout`. Например:

```shell
printf 'connect_timeout=60\ninteractive_timeout=60\nwait_timeout=60' >> /etc/mysql/my.cnf
```

## Задача 4


Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

### Решение

Это указывает на недостаток оперативной памяти. Необходимо исследовать настройки выделения памяти процессу `postgres`.

В Linux можно конфигурировать переменную `/proc/sys/vm/overcommit_memory`. Подробнее из [документации](https://access.redhat.com/documentation/ru-ru/red_hat_enterprise_linux/6/html/performance_tuning_guide/s-memory-captun):

> Определяет условия разрешения и отказа запросов больших объемов памяти. Возможные значения:
> * 0 (по умолчанию) — ядро использует эвристический алгоритм для расчета перерасхода памяти, принимая во внимание объем доступной памяти и число неверных запросов. Но поскольку выделение памяти осуществляется на основе эвристического, а не точного алгоритма, это может привести к превышению допустимой нагрузки на память.
> * 1 — ядро не обрабатывает перерасход памяти. При этом вероятность превышения нагрузки на память возрастает, но в то же время увеличивается производительность задач, активно использующих память.
> * 2 — отказ обработки запросов, запрашивающих память, размер которой превышает суммарный размер памяти пространства подкачки и ОЗУ в соответствии с overcommit_ratio.